function [Q_Pred,idx,Ret_C,IDX_lin_it,xq]=exomets_kmeans(k,Cexp_clean , Cexpl, time, Vars_clean,B)


warning('off','SPLINES:CHCKXYWP:NaNs')

% Evaluation of steady state regions of exometabolic concentrations by
% k-mean grouping, uses a threshold determined by the sister function
% exomets_kmeans_thresholding to choose the optimum number of centroids
% Andrei Ligema
% 2019 DTU
% outputs:
% idx is the cluster assignment for each time span
% C is the q value for each metabolite for each of the clusters
% sumd is sum of distances to each cluster, within cluster
% D is the distances to each centroid from each point

% retreiving the metabolite concentrations from the kmeans data
% preliminary implementation, depends on all groupings being continuous

% q values are assigned to each interval

% inputs:   [k] Number of clusters, determined by
%           exomets_k_means_thresholding or user
%           [Cexp_clean] Table of metabolite concentrations across
%           experimental replicates, imported from exomets_outlier_removal
%           [Cexpl] List of metabolite names
%           [time] Time indices of experimental data points
%           [Vars_clean] List of bioreactor variables
%           [B] Index of experimental replicate
% outputs   [Q_Pred] Predicted q values per cluster per metabolite
%           [idx] raw cluster index positions
%           [Ret_C] Retrieved concentration curves based on reconstruction
%           using Q_pred and growth curves
%           [IDX_lin_it] Linearised version of [idx] for graphing
%           [xq] linearised time indices for interpolated measurements





reps=1; % number of repeats, used to offset stochastic variability in k-means
        % if reps>1 then the procedure will repeat and choose the
        % clustering attempt with the lowest error score
xq=linspace(time(1),time(end),500); % Procedure requires an interpolated "y" with linearised "x" to function effectively

q=[];
Interp_Cexp=[];
  
 Cexp=Cexp_clean{1,B}{1,1}; % importing variables from outlier removal tables
 Vars=Vars_clean{1,B}{1,1}; % this may be replaced for non-repeat or non-cleaned data
    
[q,Met_Exp,Delta_Vars,Interp_Cexp,Interp_Vars]=k_means_input(time,Cexp,Vars); 



[idx,C,~,~]=kmeans(q,k,'emptyaction','drop','onlinephase','on','Replicates',reps);
% Input:        [q] table of metabolite fluxes generated by k_means_input
%               [k] number of clusters
%               'emptyaction' action to take if a cluster loses all members,
%               default 'drop'
%               'onlinephase' Optimises the cluster assignment to create a
%               local minima solution, default 'on'
%               'Replicates' number of repeats to take to compensate for
%               stochastic variability
% Output:       [C] 

% generating Q_Pred from the cluster assignments 
for j=1:size(C,2) 
    for i=1:size(idx,1)
Q_Pred(i,j)=C(idx(i),j);
    end
end
% and testing distances from real values
for j=1:size(q,2)
    for i=1:size(q,1)
        obs=abs(q(i,j));
        exp=abs(Q_Pred(i,j));
        Diffs(i,j)=((obs-exp)^2)/exp;
    end
end


% Repeat best fit to adjust for stochastic variability in k-means
% choose the best version of the fit
repeats={};

for r=1:reps
[idx_r,C_r]=kmeans(q,k);
repeats{r,1}={idx_r};
repeats{r,2}={C_r};

for j=1:size(C_r,2)
    for i=1:size(idx_r,1)
        
Q_Pred_r(i,j)=repeats{r,2}{1}(repeats{r,1}{1}(i),j);
    end
end

% checking error for each repeat
for j=1:size(q,2)
    for i=1:size(q,1)
        obs=abs(q(i,j));
        exp=abs(Q_Pred_r(i,j));
        Diffs(i,j)=((obs-exp)^2)/exp;
    end
end
CHI_r(r)=nansum(Diffs,'all');
end
CHI_best=min(CHI_r);
CHI_best_loc=find(CHI_r==CHI_best,1);

idx=cell2mat(repeats{CHI_best_loc,1});
C=cell2mat(repeats{CHI_best_loc,2});
% exports best repeat as definative version of cluster model

for j=1:size(C,2)
    for i=1:size(idx,1)
Q_Pred(i,j)=C(idx(i),j);
    end
end
for j=1:size(q,2)
    for i=1:size(q,1)
        obs=abs(q(i,j));
        exp=abs(Q_Pred(i,j));
        Diffs(i,j)=((obs-exp)^2)/exp;
    end
end

% Generate CHI^2 sum of differences, invalid for test statistic use because
% degrees of freedom are *very* difficult to calculate for this kind of
% problem
CHI2=nansum(Diffs,'all');

% end of repeats testing

% Retrieves concentration curves from the q predictions, first by
% generating the deltas for each
for j=1:size(C,2)
    for i=1:size(idx,1)
Ret_DeltaC(i,j)=Q_Pred(i,j)*Interp_Vars(i,4);
    end
end

% then by restoring the deltas to time-point concentrations
Ret_C(1,:)=Interp_Cexp(1,:);
for j=1:size(C,2)
    for i=2:size(xq,2)
        Ret_C(i,j)=Ret_C(i-1,j)+Ret_DeltaC(i-1,j);
    end
end

% linearises the assignment of centroid numbers for clarity
Lin=1;
IDX_lin(1)=1;
for j=2:length(idx)
    if idx(j)~=idx(j-1)
        Lin=Lin+1;
    IDX_lin(j)=Lin;
    else
        IDX_lin(j)=Lin;
    end
end


% Plotting outputs

output_q=input('Would you like to view the fitted curves? (Y/N) \n','s');
if output_q=='Y'
    figure(1)

plot(xq(1:length(IDX_lin)),IDX_lin,'*')
ylabel('Group Assignment');
xlabel('Time Interval');
ylim([0,k]);
 


figure(3)
for i=1:size(Cexpl,2)
    subplot(6,7,i)
    plot(xq,Interp_Cexp(:,i),'r')
    hold on
    plot(xq,Ret_C(:,i),'b')
    title(Cexpl(i))
end


figure(6)
for i=1:size(Cexpl,2)
    subplot(6,7,i)
    hold on
    plot(xq(1:499),Q_Pred(:,i))
    hold on
    plot(xq(1:499),q(:,i),'r')
    title(Cexpl(i))
end




else
end

IDX_lin_it=IDX_lin;
clear output_q


end

function [q,Met_Exp,Delta_Vars,Interp_Cexp,Interp_Vars]=k_means_input(time,Cexp,Vars)
% sets up input data for use in k-means clustering
% This procedure is imperfect as it relies on a standard process for cubic
% spline interpolation. Therefore generating "new" data points.
% Future iterations will use the BDMFA procedure used elsewhere in the
% process to generate mass-balanced interpolations that are more
% biologically relevant


xq=linspace(time(1),time(end),500);

p=5e-4; % parameter for spline fitting 

Interp_Vars(:,1)=xq; % interp_vars replicates [vars_clean]

for j=2:size(Vars,2) % generating spline function and interpolated values for [Vars], supporting growth calculations
    splinefun=csaps(time,Vars(:,j),p);
    for i=1:length(xq)
        Interp_Vars(i,j)=ppval(splinefun,xq(i));
    end
end

V=1;% replaces sample volume as a stepped function consistent with experimental
% measurements
for j=1:length(xq)
    if xq(j)>time(V)
        V=V+1;
    else
    end
    Interp_Vars(j,3)=Vars(V,3);
end
% Gives values of time, VCD, vol, OUR and biomass for the linspace xq


% depricated
% Interp_Vars(:,4)=Interp_Vars(:,2).*Interp_Vars(:,3).*0.36;



for j=1:size(Interp_Vars,2)
    for i=1:length(xq)-1
        Delta_Vars(i,j)=Interp_Vars(i+1,j)-Interp_Vars(i,j);
    end
end
% produces a table of delta values for time, VCD, vol and biomass
% done establishing bioreactor variables


for j=1:size(Cexp,2)
    Met_Exp(:,1)=time;
splinefun=csaps(time,Cexp(:,j),p);
for i=1:length(xq)
    Interp_Cexp(i,j)=ppval(splinefun,xq(i));
end    
end
% generates a full table of interpolated concentration values for each
% metabolite



for j=1:size(Interp_Cexp,2)
    for i=1:length(xq)-1
        DeltaC(i,j)=Interp_Cexp(i+1,j)-Interp_Cexp(i,j);
    end
end
% full table of differences for the metabolites across linearised
% timepoints


for j=1:size(DeltaC,2)
    for i=1:size(DeltaC,1)
        q(i,j)=DeltaC(i,j)/Interp_Vars(i,4);
    end
end
% evaluate q for the table of differences

% done preparing the inputs for kmeans

end


